"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveDependencies = void 0;
const path = require("path");
const resolve = require("enhanced-resolve");
const fs = require("fs");
const source_map_1 = require("source-map");
const transpiler_1 = require("./transpiler");
const utils_1 = require("../utils");
const diagnostics_1 = require("./diagnostics");
const CompilerOptions_1 = require("../CompilerOptions");
const resolver = resolve.ResolverFactory.createResolver({
    extensions: [".lua"],
    enforceExtension: true,
    fileSystem: { ...new resolve.CachedInputFileSystem(fs) },
    useSyncFileSystemCalls: true,
});
class ResolutionContext {
    constructor(program, options, emitHost) {
        this.program = program;
        this.options = options;
        this.emitHost = emitHost;
        this.resultsCache = new Map();
        this.noResolvePaths = new Set(options.noResolvePaths);
    }
    resolve(file, required) {
        if (this.noResolvePaths.has(required)) {
            if (this.options.tstlVerbose) {
                console.log(`Skipping module resolution of ${required} as it is in the tsconfig noResolvePaths.`);
            }
            return { resolvedFiles: [], diagnostics: [] };
        }
        const resolvedDependency = resolveDependency(file, required, this.program, this.emitHost);
        if (resolvedDependency) {
            if (this.options.tstlVerbose) {
                console.log(`Resolved ${required} to ${(0, utils_1.normalizeSlashes)(resolvedDependency)}`);
            }
            // Figure out resolved require path and dependency output path
            const resolvedRequire = (0, transpiler_1.getEmitPathRelativeToOutDir)(resolvedDependency, this.program);
            if (shouldRewriteRequires(resolvedDependency, this.program)) {
                replaceRequireInCode(file, required, resolvedRequire);
                replaceRequireInSourceMap(file, required, resolvedRequire);
            }
            // Check cache to prevent resolving nested dependencies double to break dependency loops
            if (this.resultsCache.has(resolvedDependency)) {
                if (this.options.tstlVerbose) {
                    console.log(`Resolution cache hit for ${(0, utils_1.normalizeSlashes)(resolvedDependency)}`);
                }
                return this.resultsCache.get(resolvedDependency);
            }
            // If dependency is not part of project, add dependency to output and resolve its dependencies recursively
            if (shouldIncludeDependency(resolvedDependency, this.program)) {
                // If dependency resolved successfully, read its content
                const dependencyContent = this.emitHost.readFile(resolvedDependency);
                if (dependencyContent === undefined) {
                    return { resolvedFiles: [], diagnostics: [(0, diagnostics_1.couldNotReadDependency)(resolvedDependency)] };
                }
                const dependency = {
                    fileName: resolvedDependency,
                    code: dependencyContent,
                };
                const nestedDependencies = resolveFileDependencies(dependency, this);
                // Cache result and return
                const result = {
                    resolvedFiles: [dependency, ...nestedDependencies.resolvedFiles],
                    diagnostics: [...nestedDependencies.diagnostics],
                };
                this.resultsCache.set(resolvedDependency, result);
                return result;
            }
            else {
                const result = {
                    resolvedFiles: [],
                    diagnostics: [],
                };
                this.resultsCache.set(resolvedDependency, result);
                return result;
            }
        }
        else {
            const fallbackRequire = fallbackResolve(required, (0, transpiler_1.getSourceDir)(this.program), path.dirname(file.fileName));
            replaceRequireInCode(file, required, fallbackRequire);
            replaceRequireInSourceMap(file, required, fallbackRequire);
            return {
                resolvedFiles: [],
                diagnostics: [
                    (0, diagnostics_1.couldNotResolveRequire)(required, path.relative((0, transpiler_1.getProjectRoot)(this.program), file.fileName)),
                ],
            };
        }
    }
}
function resolveDependencies(program, files, emitHost) {
    const outFiles = [...files];
    const diagnostics = [];
    const options = program.getCompilerOptions();
    const resolutionContext = new ResolutionContext(program, options, emitHost);
    // Resolve dependencies for all processed files
    for (const file of files) {
        if (options.tstlVerbose) {
            console.log(`Resolving dependencies for ${(0, utils_1.normalizeSlashes)(file.fileName)}`);
        }
        const resolutionResult = resolveFileDependencies(file, resolutionContext);
        outFiles.push(...resolutionResult.resolvedFiles);
        diagnostics.push(...resolutionResult.diagnostics);
    }
    return { resolvedFiles: deduplicateResolvedFiles(outFiles), diagnostics };
}
exports.resolveDependencies = resolveDependencies;
function deduplicateResolvedFiles(files) {
    return [...new Map(files.map(f => [f.fileName, f])).values()];
}
function resolveFileDependencies(file, context) {
    const dependencies = [];
    const diagnostics = [];
    for (const required of findRequiredPaths(file.code)) {
        // Do no resolve lualib
        if (required === "lualib_bundle") {
            dependencies.push({ fileName: "lualib_bundle", code: "" });
            continue;
        }
        // Do not resolve noResolution paths
        if (required.startsWith("@NoResolution:")) {
            // Remove @NoResolution prefix if not building in library mode
            if (!isBuildModeLibrary(context.program)) {
                const path = required.replace("@NoResolution:", "");
                replaceRequireInCode(file, required, path);
                replaceRequireInSourceMap(file, required, path);
            }
            // Skip
            continue;
        }
        // Try to resolve the import starting from the directory `file` is in
        const resolvedDependency = context.resolve(file, required);
        dependencies.push(...resolvedDependency.resolvedFiles);
        diagnostics.push(...resolvedDependency.diagnostics);
    }
    return { resolvedFiles: deduplicateResolvedFiles(dependencies), diagnostics };
}
function resolveDependency(requiringFile, dependency, program, emitHost) {
    var _a;
    const options = program.getCompilerOptions();
    const fileDirectory = path.dirname(requiringFile.fileName);
    if (options.tstlVerbose) {
        console.log(`Resolving "${dependency}" from ${(0, utils_1.normalizeSlashes)(requiringFile.fileName)}`);
    }
    // Check if the import is relative
    const isRelative = ["/", "./", "../"].some(p => dependency.startsWith(p));
    // If the import is relative, always resolve it relative to the requiring file
    // If the import is not relative, resolve it relative to options.baseUrl if it is set
    const relativeTo = isRelative ? fileDirectory : (_a = options.baseUrl) !== null && _a !== void 0 ? _a : fileDirectory;
    // Check if file is a file in the project
    const resolvedPath = path.join(relativeTo, dependency);
    const possibleProjectFiles = [
        resolvedPath,
        resolvedPath + ".ts",
        path.join(resolvedPath, "index.ts"),
        resolvedPath + ".tsx",
        path.join(resolvedPath, "index.tsx"), // tsx index
    ];
    for (const possibleFile of possibleProjectFiles) {
        if (isProjectFile(possibleFile, program)) {
            return possibleFile;
        }
    }
    // Check if this is a lua file in the project sources
    const possibleLuaProjectFiles = [
        resolvedPath + ".lua",
        path.join(resolvedPath, "index.lua"),
        path.join(resolvedPath, "init.lua"), // lua looks for <require>/init.lua if it cannot find <require>.lua
    ];
    for (const possibleFile of possibleLuaProjectFiles) {
        if (emitHost.fileExists(possibleFile)) {
            return possibleFile;
        }
    }
    // Check if this is a sibling of a required lua file
    if (requiringFile.fileName.endsWith(".lua")) {
        const luaFilePath = resolveLuaPath(fileDirectory, dependency, emitHost);
        if (luaFilePath) {
            return luaFilePath;
        }
    }
    // Not a TS file in our project sources, use resolver to check if we can find dependency
    try {
        const resolveResult = resolver.resolveSync({}, fileDirectory, dependency);
        if (resolveResult) {
            return resolveResult;
        }
    }
    catch (e) {
        // resolveSync errors if it fails to resolve
    }
    return undefined;
}
function resolveLuaPath(fromPath, dependency, emitHost) {
    const splitDependency = dependency.split(".");
    if (splitDependency.length === 1) {
        // If dependency has just one part (the file), look for a lua file with that name
        const fileDirectory = walkUpFileTreeUntil(fromPath, dir => emitHost.fileExists(path.join(dir, dependency) + ".lua"));
        if (fileDirectory) {
            return path.join(fileDirectory, dependency) + ".lua";
        }
    }
    else {
        // If dependency has multiple parts, look for the first directory of the require path, which must be in the lua root
        const luaRoot = walkUpFileTreeUntil(fromPath, dir => emitHost.directoryExists(path.join(dir, splitDependency[0])));
        if (luaRoot) {
            return path.join(luaRoot, dependency.replace(/\./g, path.sep)) + ".lua";
        }
    }
}
function walkUpFileTreeUntil(fromDirectory, predicate) {
    const currentDir = path.normalize(fromDirectory).split(path.sep);
    while (currentDir.length > 0) {
        const dir = currentDir.join(path.sep);
        if (predicate(dir)) {
            return dir;
        }
        currentDir.pop();
    }
    return undefined;
}
function shouldRewriteRequires(resolvedDependency, program) {
    return !isNodeModulesFile(resolvedDependency) || !isBuildModeLibrary(program);
}
function shouldIncludeDependency(resolvedDependency, program) {
    // Never include lua files (again) that are transpiled from project sources
    if (!hasSourceFileInProject(resolvedDependency, program)) {
        // Always include lua files not in node_modules (internal lua sources)
        if (!isNodeModulesFile(resolvedDependency)) {
            return true;
        }
        else {
            // Only include node_modules files if not in library mode
            return !isBuildModeLibrary(program);
        }
    }
    return false;
}
function isBuildModeLibrary(program) {
    return program.getCompilerOptions().buildMode === CompilerOptions_1.BuildMode.Library;
}
function findRequiredPaths(code) {
    // Find all require("<path>") paths in a lua code string
    const paths = [];
    const pattern = /(^|\s|;|=)require\("(.+?)"\)/g;
    // eslint-disable-next-line @typescript-eslint/ban-types
    let match;
    while ((match = pattern.exec(code))) {
        paths.push(match[2]);
    }
    return paths;
}
function replaceRequireInCode(file, originalRequire, newRequire) {
    const requirePath = (0, utils_1.formatPathToLuaPath)(newRequire.replace(".lua", ""));
    // Escape special characters to prevent the regex from breaking...
    const escapedRequire = originalRequire.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    file.code = file.code.replace(new RegExp(`(^|\\s|;|=)require\\("${escapedRequire}"\\)`), `$1require("${requirePath}")`);
}
function replaceRequireInSourceMap(file, originalRequire, newRequire) {
    const requirePath = (0, utils_1.formatPathToLuaPath)(newRequire.replace(".lua", ""));
    if (file.sourceMapNode) {
        replaceInSourceMap(file.sourceMapNode, file.sourceMapNode, `"${originalRequire}"`, `"${requirePath}"`);
    }
}
function replaceInSourceMap(node, parent, require, resolvedRequire) {
    if ((!node.children || node.children.length === 0) && node.toString() === require) {
        parent.children = [new source_map_1.SourceNode(node.line, node.column, node.source, [resolvedRequire])];
        return true; // Stop after finding the first occurrence
    }
    if (node.children) {
        for (const c of node.children) {
            if (replaceInSourceMap(c, node, require, resolvedRequire)) {
                return true; // Occurrence found in one of the children
            }
        }
    }
    return false; // Did not find the require
}
function isNodeModulesFile(filePath) {
    return path
        .normalize(filePath)
        .split(path.sep)
        .some(p => p === "node_modules");
}
function isProjectFile(file, program) {
    return program.getSourceFile(file) !== undefined;
}
function hasSourceFileInProject(filePath, program) {
    const pathWithoutExtension = (0, utils_1.trimExtension)(filePath);
    return (isProjectFile(pathWithoutExtension + ".ts", program) ||
        isProjectFile(pathWithoutExtension + ".tsx", program) ||
        isProjectFile(pathWithoutExtension + ".json", program));
}
// Transform an import path to a lua require that is probably not correct, but can be used as fallback when regular resolution fails
function fallbackResolve(required, sourceRootDir, fileDir) {
    return (0, utils_1.formatPathToLuaPath)(path
        .normalize(path.join(path.relative(sourceRootDir, fileDir), required))
        .split(path.sep)
        .filter(s => s !== "." && s !== "..")
        .join(path.sep));
}
//# sourceMappingURL=resolve.js.map