"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformOperatorMappingExpression = exports.isOperatorMapping = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const extensions = require("../../utils/language-extensions");
const utils_1 = require("../../../utils");
const typescript_1 = require("../../utils/typescript");
const CompilerOptions_1 = require("../../../CompilerOptions");
const diagnostics_1 = require("../../utils/diagnostics");
const binaryOperatorMappings = new Map([
    [extensions.ExtensionKind.AdditionOperatorType, lua.SyntaxKind.AdditionOperator],
    [extensions.ExtensionKind.AdditionOperatorMethodType, lua.SyntaxKind.AdditionOperator],
    [extensions.ExtensionKind.SubtractionOperatorType, lua.SyntaxKind.SubtractionOperator],
    [extensions.ExtensionKind.SubtractionOperatorMethodType, lua.SyntaxKind.SubtractionOperator],
    [extensions.ExtensionKind.MultiplicationOperatorType, lua.SyntaxKind.MultiplicationOperator],
    [extensions.ExtensionKind.MultiplicationOperatorMethodType, lua.SyntaxKind.MultiplicationOperator],
    [extensions.ExtensionKind.DivisionOperatorType, lua.SyntaxKind.DivisionOperator],
    [extensions.ExtensionKind.DivisionOperatorMethodType, lua.SyntaxKind.DivisionOperator],
    [extensions.ExtensionKind.ModuloOperatorType, lua.SyntaxKind.ModuloOperator],
    [extensions.ExtensionKind.ModuloOperatorMethodType, lua.SyntaxKind.ModuloOperator],
    [extensions.ExtensionKind.PowerOperatorType, lua.SyntaxKind.PowerOperator],
    [extensions.ExtensionKind.PowerOperatorMethodType, lua.SyntaxKind.PowerOperator],
    [extensions.ExtensionKind.FloorDivisionOperatorType, lua.SyntaxKind.FloorDivisionOperator],
    [extensions.ExtensionKind.FloorDivisionOperatorMethodType, lua.SyntaxKind.FloorDivisionOperator],
    [extensions.ExtensionKind.BitwiseAndOperatorType, lua.SyntaxKind.BitwiseAndOperator],
    [extensions.ExtensionKind.BitwiseAndOperatorMethodType, lua.SyntaxKind.BitwiseAndOperator],
    [extensions.ExtensionKind.BitwiseOrOperatorType, lua.SyntaxKind.BitwiseOrOperator],
    [extensions.ExtensionKind.BitwiseOrOperatorMethodType, lua.SyntaxKind.BitwiseOrOperator],
    [extensions.ExtensionKind.BitwiseExclusiveOrOperatorType, lua.SyntaxKind.BitwiseExclusiveOrOperator],
    [extensions.ExtensionKind.BitwiseExclusiveOrOperatorMethodType, lua.SyntaxKind.BitwiseExclusiveOrOperator],
    [extensions.ExtensionKind.BitwiseLeftShiftOperatorType, lua.SyntaxKind.BitwiseLeftShiftOperator],
    [extensions.ExtensionKind.BitwiseLeftShiftOperatorMethodType, lua.SyntaxKind.BitwiseLeftShiftOperator],
    [extensions.ExtensionKind.BitwiseRightShiftOperatorType, lua.SyntaxKind.BitwiseRightShiftOperator],
    [extensions.ExtensionKind.BitwiseRightShiftOperatorMethodType, lua.SyntaxKind.BitwiseRightShiftOperator],
    [extensions.ExtensionKind.ConcatOperatorType, lua.SyntaxKind.ConcatOperator],
    [extensions.ExtensionKind.ConcatOperatorMethodType, lua.SyntaxKind.ConcatOperator],
    [extensions.ExtensionKind.LessThanOperatorType, lua.SyntaxKind.LessThanOperator],
    [extensions.ExtensionKind.LessThanOperatorMethodType, lua.SyntaxKind.LessThanOperator],
    [extensions.ExtensionKind.GreaterThanOperatorType, lua.SyntaxKind.GreaterThanOperator],
    [extensions.ExtensionKind.GreaterThanOperatorMethodType, lua.SyntaxKind.GreaterThanOperator],
]);
const unaryOperatorMappings = new Map([
    [extensions.ExtensionKind.NegationOperatorType, lua.SyntaxKind.NegationOperator],
    [extensions.ExtensionKind.NegationOperatorMethodType, lua.SyntaxKind.NegationOperator],
    [extensions.ExtensionKind.BitwiseNotOperatorType, lua.SyntaxKind.BitwiseNotOperator],
    [extensions.ExtensionKind.BitwiseNotOperatorMethodType, lua.SyntaxKind.BitwiseNotOperator],
    [extensions.ExtensionKind.LengthOperatorType, lua.SyntaxKind.LengthOperator],
    [extensions.ExtensionKind.LengthOperatorMethodType, lua.SyntaxKind.LengthOperator],
]);
const operatorMapExtensions = [...binaryOperatorMappings.keys(), ...unaryOperatorMappings.keys()];
const bitwiseOperatorMapExtensions = new Set([
    extensions.ExtensionKind.BitwiseAndOperatorType,
    extensions.ExtensionKind.BitwiseAndOperatorMethodType,
    extensions.ExtensionKind.BitwiseOrOperatorType,
    extensions.ExtensionKind.BitwiseOrOperatorMethodType,
    extensions.ExtensionKind.BitwiseExclusiveOrOperatorType,
    extensions.ExtensionKind.BitwiseExclusiveOrOperatorMethodType,
    extensions.ExtensionKind.BitwiseLeftShiftOperatorType,
    extensions.ExtensionKind.BitwiseLeftShiftOperatorMethodType,
    extensions.ExtensionKind.BitwiseRightShiftOperatorType,
    extensions.ExtensionKind.BitwiseRightShiftOperatorMethodType,
    extensions.ExtensionKind.BitwiseNotOperatorType,
    extensions.ExtensionKind.BitwiseNotOperatorMethodType,
]);
function getOperatorMapExtensionKindForCall(context, node) {
    const type = (0, typescript_1.getFunctionTypeForCall)(context, node);
    return type && operatorMapExtensions.find(extensionKind => extensions.isExtensionType(type, extensionKind));
}
function isOperatorMapping(context, node) {
    if (ts.isCallExpression(node)) {
        return getOperatorMapExtensionKindForCall(context, node) !== undefined;
    }
    else {
        const type = context.checker.getTypeAtLocation(node);
        return operatorMapExtensions.some(extensionKind => extensions.isExtensionType(type, extensionKind));
    }
}
exports.isOperatorMapping = isOperatorMapping;
function transformOperatorMappingExpression(context, node, isOptionalCall) {
    const extensionKind = getOperatorMapExtensionKindForCall(context, node);
    if (!extensionKind)
        return undefined;
    if (isOptionalCall) {
        context.diagnostics.push((0, diagnostics_1.unsupportedBuiltinOptionalCall)(node));
        return lua.createNilLiteral();
    }
    const isBefore53 = context.luaTarget === CompilerOptions_1.LuaTarget.Lua51 ||
        context.luaTarget === CompilerOptions_1.LuaTarget.Lua52 ||
        context.luaTarget === CompilerOptions_1.LuaTarget.LuaJIT ||
        context.luaTarget === CompilerOptions_1.LuaTarget.Universal;
    if (isBefore53) {
        const luaTarget = context.luaTarget === CompilerOptions_1.LuaTarget.Universal ? CompilerOptions_1.LuaTarget.Lua51 : context.luaTarget;
        if (bitwiseOperatorMapExtensions.has(extensionKind)) {
            context.diagnostics.push((0, diagnostics_1.unsupportedForTarget)(node, "Native bitwise operations", luaTarget));
        }
        else if (extensionKind === extensions.ExtensionKind.FloorDivisionOperatorType ||
            extensionKind === extensions.ExtensionKind.FloorDivisionOperatorMethodType) {
            context.diagnostics.push((0, diagnostics_1.unsupportedForTarget)(node, "Floor division operator", luaTarget));
        }
    }
    const args = node.arguments.slice();
    if (binaryOperatorMappings.has(extensionKind)) {
        if (args.length === 1 &&
            (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
            args.unshift(node.expression.expression);
        }
        const luaOperator = binaryOperatorMappings.get(extensionKind);
        (0, utils_1.assert)(luaOperator);
        return lua.createBinaryExpression(context.transformExpression(args[0]), context.transformExpression(args[1]), luaOperator);
    }
    else {
        let arg;
        if (args.length === 0 &&
            (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
            arg = node.expression.expression;
        }
        else {
            arg = args[0];
        }
        const luaOperator = unaryOperatorMappings.get(extensionKind);
        (0, utils_1.assert)(luaOperator);
        return lua.createUnaryExpression(context.transformExpression(arg), luaOperator);
    }
}
exports.transformOperatorMappingExpression = transformOperatorMappingExpression;
//# sourceMappingURL=operators.js.map