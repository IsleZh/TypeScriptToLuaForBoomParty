"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformTableExtensionCall = exports.isTableNewCall = exports.isTableExtensionIdentifier = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const extensions = require("../../utils/language-extensions");
const typescript_1 = require("../../utils/typescript");
const expression_list_1 = require("../expression-list");
const diagnostics_1 = require("../../utils/diagnostics");
const tableCallExtensions = [
    extensions.ExtensionKind.TableDeleteType,
    extensions.ExtensionKind.TableDeleteMethodType,
    extensions.ExtensionKind.TableGetType,
    extensions.ExtensionKind.TableGetMethodType,
    extensions.ExtensionKind.TableHasType,
    extensions.ExtensionKind.TableHasMethodType,
    extensions.ExtensionKind.TableSetType,
    extensions.ExtensionKind.TableSetMethodType,
];
const tableExtensions = [extensions.ExtensionKind.TableNewType, ...tableCallExtensions];
function getTableExtensionKindForCall(context, node, validExtensions) {
    const type = (0, typescript_1.getFunctionTypeForCall)(context, node);
    return type && validExtensions.find(extensionKind => extensions.isExtensionType(type, extensionKind));
}
function isTableExtensionIdentifier(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return tableExtensions.some(extensionKind => extensions.isExtensionType(type, extensionKind));
}
exports.isTableExtensionIdentifier = isTableExtensionIdentifier;
function isTableNewCall(context, node) {
    const type = context.checker.getTypeAtLocation(node.expression);
    return extensions.isExtensionType(type, extensions.ExtensionKind.TableNewType);
}
exports.isTableNewCall = isTableNewCall;
function transformTableExtensionCall(context, node, isOptionalCall) {
    const extensionType = getTableExtensionKindForCall(context, node, tableCallExtensions);
    if (!extensionType)
        return;
    if (isOptionalCall) {
        context.diagnostics.push((0, diagnostics_1.unsupportedBuiltinOptionalCall)(node));
        return lua.createNilLiteral();
    }
    if (extensionType === extensions.ExtensionKind.TableDeleteType ||
        extensionType === extensions.ExtensionKind.TableDeleteMethodType) {
        return transformTableDeleteExpression(context, node, extensionType);
    }
    if (extensionType === extensions.ExtensionKind.TableGetType ||
        extensionType === extensions.ExtensionKind.TableGetMethodType) {
        return transformTableGetExpression(context, node, extensionType);
    }
    if (extensionType === extensions.ExtensionKind.TableHasType ||
        extensionType === extensions.ExtensionKind.TableHasMethodType) {
        return transformTableHasExpression(context, node, extensionType);
    }
    if (extensionType === extensions.ExtensionKind.TableSetType ||
        extensionType === extensions.ExtensionKind.TableSetMethodType) {
        return transformTableSetExpression(context, node, extensionType);
    }
}
exports.transformTableExtensionCall = transformTableExtensionCall;
function transformTableDeleteExpression(context, node, extensionKind) {
    const args = node.arguments.slice();
    if (extensionKind === extensions.ExtensionKind.TableDeleteMethodType &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1] = nil
    const [table, accessExpression] = (0, expression_list_1.transformExpressionList)(context, args);
    context.addPrecedingStatements(lua.createAssignmentStatement(lua.createTableIndexExpression(table, accessExpression), lua.createNilLiteral(), node));
    return lua.createBooleanLiteral(true);
}
function transformTableGetExpression(context, node, extensionKind) {
    const args = node.arguments.slice();
    if (extensionKind === extensions.ExtensionKind.TableGetMethodType &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    const [table, accessExpression] = (0, expression_list_1.transformExpressionList)(context, args);
    // arg0[arg1]
    return lua.createTableIndexExpression(table, accessExpression, node);
}
function transformTableHasExpression(context, node, extensionKind) {
    const args = node.arguments.slice();
    if (extensionKind === extensions.ExtensionKind.TableHasMethodType &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1]
    const [table, accessExpression] = (0, expression_list_1.transformExpressionList)(context, args);
    const tableIndexExpression = lua.createTableIndexExpression(table, accessExpression);
    // arg0[arg1] ~= nil
    return lua.createBinaryExpression(tableIndexExpression, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
}
function transformTableSetExpression(context, node, extensionKind) {
    const args = node.arguments.slice();
    if (extensionKind === extensions.ExtensionKind.TableSetMethodType &&
        (ts.isPropertyAccessExpression(node.expression) || ts.isElementAccessExpression(node.expression))) {
        // In case of method (no table argument), push method owner to front of args list
        args.unshift(node.expression.expression);
    }
    // arg0[arg1] = arg2
    const [table, accessExpression, value] = (0, expression_list_1.transformExpressionList)(context, args);
    context.addPrecedingStatements(lua.createAssignmentStatement(lua.createTableIndexExpression(table, accessExpression), value, node));
    return lua.createNilLiteral();
}
//# sourceMappingURL=table.js.map