"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMultiAssignmentViolations = exports.shouldMultiReturnCallBeWrapped = exports.isInMultiReturnFunction = exports.isMultiFunctionNode = exports.isMultiReturnCall = exports.returnsMultiType = exports.isMultiFunctionCall = exports.canBeMultiReturnType = exports.isMultiReturnType = void 0;
const ts = require("typescript");
const extensions = require("../../utils/language-extensions");
const typescript_1 = require("../../utils/typescript");
const iterable_1 = require("./iterable");
const diagnostics_1 = require("../../utils/diagnostics");
function isMultiReturnType(type) {
    return extensions.isExtensionType(type, extensions.ExtensionKind.MultiType);
}
exports.isMultiReturnType = isMultiReturnType;
function canBeMultiReturnType(type) {
    return isMultiReturnType(type) || (type.isUnion() && type.types.some(canBeMultiReturnType));
}
exports.canBeMultiReturnType = canBeMultiReturnType;
function isMultiFunctionCall(context, expression) {
    return isMultiFunctionNode(context, expression.expression);
}
exports.isMultiFunctionCall = isMultiFunctionCall;
function returnsMultiType(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    const type = signature === null || signature === void 0 ? void 0 : signature.getReturnType();
    return type ? isMultiReturnType(type) : false;
}
exports.returnsMultiType = returnsMultiType;
function isMultiReturnCall(context, expression) {
    return ts.isCallExpression(expression) && returnsMultiType(context, expression);
}
exports.isMultiReturnCall = isMultiReturnCall;
function isMultiFunctionNode(context, node) {
    const symbol = context.checker.getSymbolAtLocation(node);
    return symbol ? extensions.isExtensionValue(context, symbol, extensions.ExtensionKind.MultiFunction) : false;
}
exports.isMultiFunctionNode = isMultiFunctionNode;
function isInMultiReturnFunction(context, node) {
    const declaration = (0, typescript_1.findFirstNodeAbove)(node, ts.isFunctionLike);
    if (!declaration) {
        return false;
    }
    const signature = context.checker.getSignatureFromDeclaration(declaration);
    const type = signature === null || signature === void 0 ? void 0 : signature.getReturnType();
    return type ? isMultiReturnType(type) : false;
}
exports.isInMultiReturnFunction = isInMultiReturnFunction;
function shouldMultiReturnCallBeWrapped(context, node) {
    if (!returnsMultiType(context, node)) {
        return false;
    }
    // Variable declaration with destructuring
    if (ts.isVariableDeclaration(node.parent) && ts.isArrayBindingPattern(node.parent.name)) {
        return false;
    }
    // Variable assignment with destructuring
    if (ts.isBinaryExpression(node.parent) &&
        node.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
        ts.isArrayLiteralExpression(node.parent.left)) {
        return false;
    }
    // Spread operator
    if (ts.isSpreadElement(node.parent)) {
        return false;
    }
    // Stand-alone expression
    if (ts.isExpressionStatement(node.parent)) {
        return false;
    }
    // Forwarded multi-return call
    if ((ts.isReturnStatement(node.parent) || ts.isArrowFunction(node.parent)) && // Body-less arrow func
        isInMultiReturnFunction(context, node)) {
        return false;
    }
    // Element access expression 'foo()[0]' will be optimized using 'select'
    if (ts.isElementAccessExpression(node.parent)) {
        return false;
    }
    // LuaIterable in for...of
    if (ts.isForOfStatement(node.parent) && (0, iterable_1.isIterableExpression)(context, node)) {
        return false;
    }
    return true;
}
exports.shouldMultiReturnCallBeWrapped = shouldMultiReturnCallBeWrapped;
function findMultiAssignmentViolations(context, node) {
    const result = [];
    for (const element of node.properties) {
        if (!ts.isShorthandPropertyAssignment(element))
            continue;
        const valueSymbol = context.checker.getShorthandAssignmentValueSymbol(element);
        if (valueSymbol) {
            if (extensions.isExtensionValue(context, valueSymbol, extensions.ExtensionKind.MultiFunction)) {
                context.diagnostics.push((0, diagnostics_1.invalidMultiFunctionUse)(element));
                result.push(element);
            }
        }
    }
    return result;
}
exports.findMultiAssignmentViolations = findMultiAssignmentViolations;
//# sourceMappingURL=multi.js.map