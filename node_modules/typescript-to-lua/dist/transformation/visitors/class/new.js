"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformNewExpression = exports.checkForLuaLibType = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lualib_1 = require("../../utils/lualib");
const call_1 = require("../call");
const table_1 = require("../language-extensions/table");
const builtinErrorTypeNames = new Set([
    "Error",
    "ErrorConstructor",
    "RangeError",
    "RangeErrorConstructor",
    "ReferenceError",
    "ReferenceErrorConstructor",
    "SyntaxError",
    "SyntaxErrorConstructor",
    "TypeError",
    "TypeErrorConstructor",
    "URIError",
    "URIErrorConstructor",
]);
// TODO: Do it in identifier?
function checkForLuaLibType(context, type) {
    if (!type.symbol)
        return;
    const name = context.checker.getFullyQualifiedName(type.symbol);
    switch (name) {
        case "Map":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Map);
            return;
        case "Set":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Set);
            return;
        case "WeakMap":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.WeakMap);
            return;
        case "WeakSet":
            (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.WeakSet);
            return;
    }
    if (builtinErrorTypeNames.has(name)) {
        (0, lualib_1.importLuaLibFeature)(context, lualib_1.LuaLibFeature.Error);
    }
}
exports.checkForLuaLibType = checkForLuaLibType;
const transformNewExpression = (node, context) => {
    var _a, _b;
    const type = context.checker.getTypeAtLocation(node);
    const annotations = (0, annotations_1.getTypeAnnotations)(type);
    if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
        context.diagnostics.push((0, diagnostics_1.annotationRemoved)(node, annotations_1.AnnotationKind.LuaTable));
    }
    if ((0, table_1.isTableNewCall)(context, node)) {
        return lua.createTableExpression(undefined, node);
    }
    const signature = context.checker.getResolvedSignature(node);
    const [name, params] = (0, call_1.transformCallAndArguments)(context, node.expression, (_a = node.arguments) !== null && _a !== void 0 ? _a : [ts.factory.createTrue()], signature);
    checkForLuaLibType(context, type);
    const customConstructorAnnotation = annotations.get(annotations_1.AnnotationKind.CustomConstructor);
    if (customConstructorAnnotation) {
        if (customConstructorAnnotation.args.length === 1) {
            return lua.createCallExpression(lua.createIdentifier(customConstructorAnnotation.args[0]), (0, call_1.transformArguments)(context, (_b = node.arguments) !== null && _b !== void 0 ? _b : []), node);
        }
        else {
            context.diagnostics.push((0, diagnostics_1.annotationInvalidArgumentCount)(node, annotations_1.AnnotationKind.CustomConstructor, customConstructorAnnotation.args.length, 1));
        }
    }
    return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.New, node, name, ...params);
};
exports.transformNewExpression = transformNewExpression;
//# sourceMappingURL=new.js.map