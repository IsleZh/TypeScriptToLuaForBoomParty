"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformCallExpression = exports.transformContextualCallExpression = exports.transformCallAndArguments = exports.transformArguments = exports.validateArguments = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const assignment_validation_1 = require("../utils/assignment-validation");
const function_context_1 = require("../utils/function-context");
const lua_ast_1 = require("../utils/lua-ast");
const safe_names_1 = require("../utils/safe-names");
const typescript_1 = require("../utils/typescript");
const access_1 = require("./access");
const multi_1 = require("./language-extensions/multi");
const diagnostics_1 = require("../utils/diagnostics");
const expression_list_1 = require("./expression-list");
const preceding_statements_1 = require("../utils/preceding-statements");
const optional_chaining_1 = require("./optional-chaining");
const language_extensions_1 = require("./language-extensions");
function validateArguments(context, params, signature) {
    if (!signature || signature.parameters.length < params.length) {
        return;
    }
    for (const [index, param] of params.entries()) {
        const signatureParameter = signature.parameters[index];
        const paramType = context.checker.getTypeAtLocation(param);
        if (signatureParameter.valueDeclaration !== undefined) {
            const signatureType = context.checker.getTypeAtLocation(signatureParameter.valueDeclaration);
            (0, assignment_validation_1.validateAssignment)(context, param, paramType, signatureType, signatureParameter.name);
        }
    }
}
exports.validateArguments = validateArguments;
function transformArguments(context, params, signature, callContext) {
    validateArguments(context, params, signature);
    return (0, expression_list_1.transformExpressionList)(context, callContext ? [callContext, ...params] : params);
}
exports.transformArguments = transformArguments;
function transformCallWithArguments(context, callExpression, transformedArguments, argPrecedingStatements, callContext) {
    let call = context.transformExpression(callExpression);
    let transformedContext;
    if (callContext) {
        transformedContext = context.transformExpression(callContext);
    }
    if (argPrecedingStatements.length > 0) {
        if (transformedContext) {
            transformedContext = (0, expression_list_1.moveToPrecedingTemp)(context, transformedContext, callContext);
        }
        call = (0, expression_list_1.moveToPrecedingTemp)(context, call, callExpression);
        context.addPrecedingStatements(argPrecedingStatements);
    }
    if (transformedContext) {
        transformedArguments.unshift(transformedContext);
    }
    return [call, transformedArguments];
}
function transformCallAndArguments(context, callExpression, params, signature, callContext) {
    const [argPrecedingStatements, transformedArguments] = (0, preceding_statements_1.transformInPrecedingStatementScope)(context, () => transformArguments(context, params, signature, callContext));
    return transformCallWithArguments(context, callExpression, transformedArguments, argPrecedingStatements);
}
exports.transformCallAndArguments = transformCallAndArguments;
function transformElementAccessCall(context, left, transformedArguments, argPrecedingStatements) {
    // Cache left-side if it has effects
    // local ____self = context; return ____self[argument](parameters);
    const selfIdentifier = lua.createIdentifier(context.createTempName("self"));
    const callContext = context.transformExpression(left.expression);
    const selfAssignment = lua.createVariableDeclarationStatement(selfIdentifier, callContext);
    context.addPrecedingStatements(selfAssignment);
    const argument = ts.isElementAccessExpression(left)
        ? (0, access_1.transformElementAccessArgument)(context, left)
        : lua.createStringLiteral(left.name.text);
    let index = lua.createTableIndexExpression(selfIdentifier, argument);
    if (argPrecedingStatements.length > 0) {
        // Cache index in temp if args had preceding statements
        index = (0, expression_list_1.moveToPrecedingTemp)(context, index);
        context.addPrecedingStatements(argPrecedingStatements);
    }
    return lua.createCallExpression(index, [selfIdentifier, ...transformedArguments]);
}
function transformContextualCallExpression(context, node, args, signature) {
    if (ts.isOptionalChain(node)) {
        return (0, optional_chaining_1.transformOptionalChain)(context, node);
    }
    const left = ts.isCallExpression(node) ? node.expression : node.tag;
    let [argPrecedingStatements, transformedArguments] = (0, preceding_statements_1.transformInPrecedingStatementScope)(context, () => transformArguments(context, args, signature));
    if (ts.isPropertyAccessExpression(left) &&
        ts.isIdentifier(left.name) &&
        (0, safe_names_1.isValidLuaIdentifier)(left.name.text, context.options) &&
        argPrecedingStatements.length === 0) {
        // table:name()
        const table = context.transformExpression(left.expression);
        return lua.createMethodCallExpression(table, lua.createIdentifier(left.name.text, left.name), transformedArguments, node);
    }
    else if (ts.isElementAccessExpression(left) || ts.isPropertyAccessExpression(left)) {
        if ((0, typescript_1.isExpressionWithEvaluationEffect)(left.expression)) {
            return transformElementAccessCall(context, left, transformedArguments, argPrecedingStatements);
        }
        else {
            let expression;
            [expression, transformedArguments] = transformCallWithArguments(context, left, transformedArguments, argPrecedingStatements, left.expression);
            return lua.createCallExpression(expression, transformedArguments, node);
        }
    }
    else if (ts.isIdentifier(left)) {
        const callContext = context.isStrict ? ts.factory.createNull() : ts.factory.createIdentifier("_G");
        let expression;
        [expression, transformedArguments] = transformCallWithArguments(context, left, transformedArguments, argPrecedingStatements, callContext);
        return lua.createCallExpression(expression, transformedArguments, node);
    }
    else {
        throw new Error(`Unsupported LeftHandSideExpression kind: ${ts.SyntaxKind[left.kind]}`);
    }
}
exports.transformContextualCallExpression = transformContextualCallExpression;
function transformPropertyCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    if (node.expression.expression.kind === ts.SyntaxKind.SuperKeyword) {
        // Super calls take the format of super.call(self,...)
        const parameters = transformArguments(context, node.arguments, signature, ts.factory.createThis());
        return lua.createCallExpression(context.transformExpression(node.expression), parameters);
    }
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    if (!signatureDeclaration || (0, function_context_1.getDeclarationContextType)(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // table:name()
        return transformContextualCallExpression(context, node, node.arguments, signature);
    }
    else {
        // table.name()
        const [callPath, parameters] = transformCallAndArguments(context, node.expression, node.arguments, signature);
        return lua.createCallExpression(callPath, parameters, node);
    }
}
function transformElementCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    if (!signatureDeclaration || (0, function_context_1.getDeclarationContextType)(context, signatureDeclaration) !== function_context_1.ContextType.Void) {
        // A contextual parameter must be given to this call expression
        return transformContextualCallExpression(context, node, node.arguments, signature);
    }
    else {
        // No context
        const [expression, parameters] = transformCallAndArguments(context, node.expression, node.arguments, signature);
        return lua.createCallExpression(expression, parameters);
    }
}
const transformCallExpression = (node, context) => {
    var _a;
    if (ts.isOptionalChain(node)) {
        return (0, optional_chaining_1.transformOptionalChain)(context, node);
    }
    const optionalContinuation = ts.isIdentifier(node.expression)
        ? (0, optional_chaining_1.getOptionalContinuationData)(node.expression)
        : undefined;
    const wrapResultInTable = (0, multi_1.isMultiReturnCall)(context, node) && (0, multi_1.shouldMultiReturnCallBeWrapped)(context, node);
    if ((0, annotations_1.isTupleReturnCall)(context, node)) {
        context.diagnostics.push((0, diagnostics_1.annotationRemoved)(node, annotations_1.AnnotationKind.TupleReturn));
    }
    const builtinOrExtensionResult = (_a = (0, builtins_1.transformBuiltinCallExpression)(context, node, optionalContinuation !== undefined)) !== null && _a !== void 0 ? _a : (0, language_extensions_1.transformLanguageExtensionCallExpression)(context, node, optionalContinuation !== undefined);
    if (builtinOrExtensionResult) {
        // unsupportedOptionalCall diagnostic already present
        return wrapResultInTable ? (0, lua_ast_1.wrapInTable)(builtinOrExtensionResult) : builtinOrExtensionResult;
    }
    if (ts.isPropertyAccessExpression(node.expression)) {
        const ownerType = context.checker.getTypeAtLocation(node.expression.expression);
        const annotations = (0, annotations_1.getTypeAnnotations)(ownerType);
        if (annotations.has(annotations_1.AnnotationKind.LuaTable)) {
            context.diagnostics.push((0, diagnostics_1.annotationRemoved)(node, annotations_1.AnnotationKind.LuaTable));
        }
        const result = transformPropertyCall(context, node);
        return wrapResultInTable ? (0, lua_ast_1.wrapInTable)(result) : result;
    }
    if (ts.isElementAccessExpression(node.expression)) {
        const result = transformElementCall(context, node);
        return wrapResultInTable ? (0, lua_ast_1.wrapInTable)(result) : result;
    }
    const signature = context.checker.getResolvedSignature(node);
    // Handle super calls properly
    if (node.expression.kind === ts.SyntaxKind.SuperKeyword) {
        const parameters = transformArguments(context, node.arguments, signature, ts.factory.createThis());
        return lua.createCallExpression(lua.createTableIndexExpression(context.transformExpression(ts.factory.createSuper()), lua.createStringLiteral("____constructor")), parameters);
    }
    const signatureDeclaration = signature === null || signature === void 0 ? void 0 : signature.getDeclaration();
    let callPath;
    let parameters;
    const isContextualCall = !signatureDeclaration || (0, function_context_1.getDeclarationContextType)(context, signatureDeclaration) !== function_context_1.ContextType.Void;
    if (!isContextualCall) {
        [callPath, parameters] = transformCallAndArguments(context, node.expression, node.arguments, signature);
    }
    else {
        // if is optionalContinuation, context will be handled by transformOptionalChain.
        const useGlobalContext = !context.isStrict && optionalContinuation === undefined;
        const callContext = useGlobalContext ? ts.factory.createIdentifier("_G") : ts.factory.createNull();
        [callPath, parameters] = transformCallAndArguments(context, node.expression, node.arguments, signature, callContext);
    }
    const callExpression = lua.createCallExpression(callPath, parameters, node);
    if (optionalContinuation && isContextualCall) {
        optionalContinuation.contextualCall = callExpression;
    }
    return wrapResultInTable ? (0, lua_ast_1.wrapInTable)(callExpression) : callExpression;
};
exports.transformCallExpression = transformCallExpression;
//# sourceMappingURL=call.js.map