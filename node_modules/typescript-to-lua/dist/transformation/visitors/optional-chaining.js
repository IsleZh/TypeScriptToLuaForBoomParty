"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformOptionalDeleteExpression = exports.transformOptionalChainWithCapture = exports.transformOptionalChain = exports.getOptionalContinuationData = exports.isOptionalContinuation = exports.captureThisValue = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const context_1 = require("../context");
const utils_1 = require("../../utils");
const preceding_statements_1 = require("../utils/preceding-statements");
const access_1 = require("./access");
const expression_list_1 = require("./expression-list");
function skipNonNullChains(chain) {
    while (ts.isNonNullChain(chain)) {
        chain = chain.expression;
    }
    return chain;
}
function flattenChain(chain) {
    chain = skipNonNullChains(chain);
    const links = [chain];
    while (!chain.questionDotToken && !ts.isTaggedTemplateExpression(chain)) {
        const nextLink = chain.expression;
        (0, utils_1.assert)(ts.isOptionalChain(nextLink));
        chain = skipNonNullChains(nextLink);
        links.unshift(chain);
    }
    return { expression: chain.expression, chain: links };
}
function transformExpressionWithThisValueCapture(context, node, thisValueCapture) {
    if (ts.isParenthesizedExpression(node)) {
        return transformExpressionWithThisValueCapture(context, node.expression, thisValueCapture);
    }
    if (ts.isPropertyAccessExpression(node)) {
        return (0, access_1.transformPropertyAccessExpressionWithCapture)(context, node, thisValueCapture);
    }
    if (ts.isElementAccessExpression(node)) {
        return (0, access_1.transformElementAccessExpressionWithCapture)(context, node, thisValueCapture);
    }
    return { expression: context.transformExpression(node) };
}
// returns thisValueCapture exactly if a temp variable was used.
function captureThisValue(context, expression, thisValueCapture, tsOriginal) {
    if (!(0, expression_list_1.shouldMoveToTemp)(context, expression, tsOriginal) && !isOptionalContinuation(tsOriginal)) {
        return expression;
    }
    const tempAssignment = lua.createAssignmentStatement(thisValueCapture, expression, tsOriginal);
    context.addPrecedingStatements(tempAssignment);
    return thisValueCapture;
}
exports.captureThisValue = captureThisValue;
const optionalContinuations = new WeakMap();
// should be translated verbatim to lua
function createOptionalContinuationIdentifier(text, tsOriginal) {
    const identifier = ts.factory.createIdentifier(text);
    ts.setOriginalNode(identifier, tsOriginal);
    optionalContinuations.set(identifier, {});
    return identifier;
}
function isOptionalContinuation(node) {
    return ts.isIdentifier(node) && optionalContinuations.has(node);
}
exports.isOptionalContinuation = isOptionalContinuation;
function getOptionalContinuationData(identifier) {
    return optionalContinuations.get(identifier);
}
exports.getOptionalContinuationData = getOptionalContinuationData;
function transformOptionalChain(context, node) {
    return transformOptionalChainWithCapture(context, node, undefined).expression;
}
exports.transformOptionalChain = transformOptionalChain;
function transformOptionalChainWithCapture(context, node, thisValueCapture, isDelete) {
    var _a;
    const luaTemp = context.createTempNameForNode(node);
    const { expression: tsLeftExpression, chain } = flattenChain(node);
    // build temp.b.c.d
    const tsTemp = createOptionalContinuationIdentifier(luaTemp.text, tsLeftExpression);
    let tsRightExpression = tsTemp;
    for (const link of chain) {
        if (ts.isPropertyAccessExpression(link)) {
            tsRightExpression = ts.factory.createPropertyAccessExpression(tsRightExpression, link.name);
        }
        else if (ts.isElementAccessExpression(link)) {
            tsRightExpression = ts.factory.createElementAccessExpression(tsRightExpression, link.argumentExpression);
        }
        else if (ts.isCallExpression(link)) {
            tsRightExpression = ts.factory.createCallExpression(tsRightExpression, undefined, link.arguments);
        }
        else {
            (0, utils_1.assertNever)(link);
        }
        ts.setOriginalNode(tsRightExpression, link);
    }
    if (isDelete) {
        tsRightExpression = ts.factory.createDeleteExpression(tsRightExpression);
        ts.setOriginalNode(tsRightExpression, isDelete);
    }
    // transform right expression first to check if thisValue capture is needed
    // capture and return thisValue if requested from outside
    let returnThisValue;
    const [rightPrecedingStatements, rightAssignment] = (0, preceding_statements_1.transformInPrecedingStatementScope)(context, () => {
        let result;
        if (thisValueCapture) {
            ({ expression: result, thisValue: returnThisValue } = transformExpressionWithThisValueCapture(context, tsRightExpression, thisValueCapture));
        }
        else {
            result = context.transformExpression(tsRightExpression);
        }
        return lua.createAssignmentStatement(luaTemp, result);
    });
    // transform left expression, handle thisValue if needed by rightExpression
    const thisValueCaptureName = context.createTempName("this");
    const leftThisValueTemp = lua.createIdentifier(thisValueCaptureName, undefined, context_1.tempSymbolId);
    let capturedThisValue;
    const rightContextualCall = (_a = getOptionalContinuationData(tsTemp)) === null || _a === void 0 ? void 0 : _a.contextualCall;
    const [leftPrecedingStatements, leftExpression] = (0, preceding_statements_1.transformInPrecedingStatementScope)(context, () => {
        let result;
        if (rightContextualCall) {
            ({ expression: result, thisValue: capturedThisValue } = transformExpressionWithThisValueCapture(context, tsLeftExpression, leftThisValueTemp));
        }
        else {
            result = context.transformExpression(tsLeftExpression);
        }
        return result;
    });
    // handle context
    if (rightContextualCall) {
        if (capturedThisValue) {
            rightContextualCall.params[0] = capturedThisValue;
            if (capturedThisValue === leftThisValueTemp) {
                context.addPrecedingStatements(lua.createVariableDeclarationStatement(leftThisValueTemp));
            }
        }
        else {
            if (context.isStrict) {
                rightContextualCall.params[0] = lua.createNilLiteral();
            }
            else {
                const identifier = lua.createIdentifier("_G");
                if (rightPrecedingStatements.length === 0) {
                    rightContextualCall.params[0] = identifier;
                }
                else {
                    const tempContext = context.createTempNameForLuaExpression(identifier);
                    rightPrecedingStatements.unshift(lua.createVariableDeclarationStatement(tempContext, identifier));
                    rightContextualCall.params[0] = tempContext;
                }
            }
        }
    }
    // <left preceding statements>
    // local temp = <left>
    // if temp ~= nil then
    //   <right preceding statements>
    //   temp = temp.b.c.d
    // end
    // return temp
    context.addPrecedingStatements([
        ...leftPrecedingStatements,
        lua.createVariableDeclarationStatement(luaTemp, leftExpression),
        lua.createIfStatement(lua.createBinaryExpression(luaTemp, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator), lua.createBlock([...rightPrecedingStatements, rightAssignment])),
    ]);
    return {
        expression: luaTemp,
        thisValue: returnThisValue,
    };
}
exports.transformOptionalChainWithCapture = transformOptionalChainWithCapture;
function transformOptionalDeleteExpression(context, node, innerExpression) {
    transformOptionalChainWithCapture(context, innerExpression, undefined, node);
    return lua.createBooleanLiteral(true, node);
}
exports.transformOptionalDeleteExpression = transformOptionalDeleteExpression;
//# sourceMappingURL=optional-chaining.js.map