"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformForOfStatement = void 0;
const ts = require("typescript");
const lua = require("../../../LuaAST");
const annotations_1 = require("../../utils/annotations");
const diagnostics_1 = require("../../utils/diagnostics");
const lualib_1 = require("../../utils/lualib");
const typescript_1 = require("../../utils/typescript");
const iterable_1 = require("../language-extensions/iterable");
const pairsIterable_1 = require("../language-extensions/pairsIterable");
const range_1 = require("../language-extensions/range");
const utils_1 = require("./utils");
function transformForOfArrayStatement(context, statement, block) {
    const valueVariable = (0, utils_1.transformForInitializer)(context, statement.initializer, block);
    const ipairsCall = lua.createCallExpression(lua.createIdentifier("ipairs"), [
        context.transformExpression(statement.expression),
    ]);
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [ipairsCall], statement);
}
function transformForOfIteratorStatement(context, statement, block) {
    const valueVariable = (0, utils_1.transformForInitializer)(context, statement.initializer, block);
    const iterable = (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.Iterator, statement.expression, context.transformExpression(statement.expression));
    return lua.createForInStatement(block, [lua.createAnonymousIdentifier(), valueVariable], [iterable], statement);
}
const transformForOfStatement = (node, context) => {
    const body = lua.createBlock((0, utils_1.transformLoopBody)(context, node));
    if (ts.isCallExpression(node.expression) && (0, range_1.isRangeFunction)(context, node.expression)) {
        return (0, range_1.transformRangeStatement)(context, node, body);
    }
    else if (ts.isCallExpression(node.expression) && (0, annotations_1.isForRangeType)(context, node.expression.expression)) {
        context.diagnostics.push((0, diagnostics_1.annotationRemoved)(node.expression, annotations_1.AnnotationKind.ForRange));
    }
    else if ((0, iterable_1.isIterableExpression)(context, node.expression)) {
        return (0, iterable_1.transformForOfIterableStatement)(context, node, body);
    }
    else if ((0, pairsIterable_1.isPairsIterableExpression)(context, node.expression)) {
        return (0, pairsIterable_1.transformForOfPairsIterableStatement)(context, node, body);
    }
    else if ((0, annotations_1.isLuaIteratorType)(context, node.expression)) {
        context.diagnostics.push((0, diagnostics_1.annotationRemoved)(node.expression, annotations_1.AnnotationKind.LuaIterator));
    }
    else if ((0, typescript_1.isArrayType)(context, context.checker.getTypeAtLocation(node.expression))) {
        return transformForOfArrayStatement(context, node, body);
    }
    else {
        return transformForOfIteratorStatement(context, node, body);
    }
};
exports.transformForOfStatement = transformForOfStatement;
//# sourceMappingURL=for-of.js.map