"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformObjectPrototypeCall = exports.transformObjectConstructorCall = void 0;
const lua = require("../../LuaAST");
const diagnostics_1 = require("../utils/diagnostics");
const lualib_1 = require("../utils/lualib");
const call_1 = require("../visitors/call");
function transformObjectConstructorCall(context, expression) {
    const method = expression.expression;
    const args = (0, call_1.transformArguments)(context, expression.arguments);
    const methodName = method.name.text;
    switch (methodName) {
        case "assign":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectAssign, expression, ...args);
        case "defineProperty":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectDefineProperty, expression, ...args);
        case "entries":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectEntries, expression, ...args);
        case "fromEntries":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectFromEntries, expression, ...args);
        case "getOwnPropertyDescriptor":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectGetOwnPropertyDescriptor, expression, ...args);
        case "getOwnPropertyDescriptors":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectGetOwnPropertyDescriptors, expression, ...args);
        case "keys":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectKeys, expression, ...args);
        case "values":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ObjectValues, expression, ...args);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(method.name, "Object", methodName));
    }
}
exports.transformObjectConstructorCall = transformObjectConstructorCall;
function transformObjectPrototypeCall(context, node, expression) {
    const signature = context.checker.getResolvedSignature(node);
    const name = expression.name.text;
    switch (name) {
        case "toString":
            const toStringIdentifier = lua.createIdentifier("tostring");
            return lua.createCallExpression(toStringIdentifier, [context.transformExpression(expression.expression)], node);
        case "hasOwnProperty":
            const expr = context.transformExpression(expression.expression);
            const parameters = (0, call_1.transformArguments)(context, node.arguments, signature);
            const rawGetIdentifier = lua.createIdentifier("rawget");
            const rawGetCall = lua.createCallExpression(rawGetIdentifier, [expr, ...parameters]);
            return lua.createBinaryExpression(rawGetCall, lua.createNilLiteral(), lua.SyntaxKind.InequalityOperator, node);
    }
}
exports.transformObjectPrototypeCall = transformObjectPrototypeCall;
//# sourceMappingURL=object.js.map