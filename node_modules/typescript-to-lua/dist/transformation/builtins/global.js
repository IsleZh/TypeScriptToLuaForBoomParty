"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformGlobalCall = void 0;
const lualib_1 = require("../utils/lualib");
const typescript_1 = require("../utils/typescript");
const call_1 = require("../visitors/call");
function transformGlobalCall(context, node) {
    const signature = context.checker.getResolvedSignature(node);
    const parameters = (0, call_1.transformArguments)(context, node.arguments, signature);
    const expressionType = context.checker.getTypeAtLocation(node.expression);
    const name = expressionType.symbol.name;
    switch (name) {
        case "SymbolConstructor":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.Symbol, node, ...parameters);
        case "NumberConstructor":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.Number, node, ...parameters);
        case "isNaN":
        case "isFinite":
            const numberParameters = (0, typescript_1.isNumberType)(context, expressionType)
                ? parameters
                : [(0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.Number, undefined, ...parameters)];
            return (0, lualib_1.transformLuaLibFunction)(context, name === "isNaN" ? lualib_1.LuaLibFeature.NumberIsNaN : lualib_1.LuaLibFeature.NumberIsFinite, node, ...numberParameters);
        case "parseFloat":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ParseFloat, node, ...parameters);
        case "parseInt":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ParseInt, node, ...parameters);
    }
}
exports.transformGlobalCall = transformGlobalCall;
//# sourceMappingURL=global.js.map