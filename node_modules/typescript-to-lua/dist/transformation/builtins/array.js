"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformArrayProperty = exports.transformArrayPrototypeCall = exports.transformArrayConstructorCall = void 0;
const lua = require("../../LuaAST");
const diagnostics_1 = require("../utils/diagnostics");
const lualib_1 = require("../utils/lualib");
const call_1 = require("../visitors/call");
const typescript_1 = require("../utils/typescript");
function transformArrayConstructorCall(context, node) {
    const expression = node.expression;
    const signature = context.checker.getResolvedSignature(node);
    const params = (0, call_1.transformArguments)(context, node.arguments, signature);
    const expressionName = expression.name.text;
    switch (expressionName) {
        case "isArray":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayIsArray, node, ...params);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(expression.name, "Array", expressionName));
    }
}
exports.transformArrayConstructorCall = transformArrayConstructorCall;
function transformArrayPrototypeCall(context, node) {
    const expression = node.expression;
    const signature = context.checker.getResolvedSignature(node);
    const [caller, params] = (0, call_1.transformCallAndArguments)(context, expression.expression, node.arguments, signature);
    const expressionName = expression.name.text;
    switch (expressionName) {
        case "concat":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayConcat, node, caller, ...params);
        case "entries":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayEntries, node, caller);
        case "push":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayPush, node, caller, ...params);
        case "reverse":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayReverse, node, caller);
        case "shift":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayShift, node, caller);
        case "unshift":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayUnshift, node, caller, ...params);
        case "sort":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArraySort, node, caller, ...params);
        case "pop":
            return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("table"), lua.createStringLiteral("remove")), [caller], node);
        case "forEach":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayForEach, node, caller, ...params);
        case "find":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayFind, node, caller, ...params);
        case "findIndex":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayFindIndex, node, caller, ...params);
        case "includes":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayIncludes, node, caller, ...params);
        case "indexOf":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayIndexOf, node, caller, ...params);
        case "map":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayMap, node, caller, ...params);
        case "filter":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayFilter, node, caller, ...params);
        case "reduce":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayReduce, node, caller, ...params);
        case "reduceRight":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayReduceRight, node, caller, ...params);
        case "some":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArraySome, node, caller, ...params);
        case "every":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayEvery, node, caller, ...params);
        case "slice":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArraySlice, node, caller, ...params);
        case "splice":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArraySplice, node, caller, ...params);
        case "join":
            const callerType = context.checker.getTypeAtLocation(expression.expression);
            const elementType = context.checker.getElementTypeOfArrayType(callerType);
            if (elementType && ((0, typescript_1.isStringType)(context, elementType) || (0, typescript_1.isNumberType)(context, elementType))) {
                const defaultSeparatorLiteral = lua.createStringLiteral(",");
                const parameters = [
                    caller,
                    node.arguments.length === 0
                        ? defaultSeparatorLiteral
                        : lua.createBinaryExpression(params[0], defaultSeparatorLiteral, lua.SyntaxKind.OrOperator),
                ];
                return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("table"), lua.createStringLiteral("concat")), parameters, node);
            }
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayJoin, node, caller, ...params);
        case "flat":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayFlat, node, caller, ...params);
        case "flatMap":
            return (0, lualib_1.transformLuaLibFunction)(context, lualib_1.LuaLibFeature.ArrayFlatMap, node, caller, ...params);
        default:
            context.diagnostics.push((0, diagnostics_1.unsupportedProperty)(expression.name, "array", expressionName));
    }
}
exports.transformArrayPrototypeCall = transformArrayPrototypeCall;
function transformArrayProperty(context, node) {
    switch (node.name.text) {
        case "length":
            const expression = context.transformExpression(node.expression);
            return lua.createUnaryExpression(expression, lua.SyntaxKind.LengthOperator, node);
        default:
            return undefined;
    }
}
exports.transformArrayProperty = transformArrayProperty;
//# sourceMappingURL=array.js.map