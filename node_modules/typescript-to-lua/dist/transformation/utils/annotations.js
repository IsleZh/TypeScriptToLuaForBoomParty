"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTagArgsFromComment = exports.isForRangeType = exports.isVarargType = exports.isLuaIteratorType = exports.isTupleReturnCall = exports.getSignatureAnnotations = exports.getFileAnnotations = exports.getNodeAnnotations = exports.getTypeAnnotations = exports.getSymbolAnnotations = exports.AnnotationKind = void 0;
const ts = require("typescript");
var AnnotationKind;
(function (AnnotationKind) {
    AnnotationKind["Extension"] = "extension";
    AnnotationKind["MetaExtension"] = "metaExtension";
    AnnotationKind["CustomConstructor"] = "customConstructor";
    AnnotationKind["CompileMembersOnly"] = "compileMembersOnly";
    AnnotationKind["NoResolution"] = "noResolution";
    AnnotationKind["PureAbstract"] = "pureAbstract";
    AnnotationKind["Phantom"] = "phantom";
    AnnotationKind["TupleReturn"] = "tupleReturn";
    AnnotationKind["LuaIterator"] = "luaIterator";
    AnnotationKind["LuaTable"] = "luaTable";
    AnnotationKind["NoSelf"] = "noSelf";
    AnnotationKind["NoSelfInFile"] = "noSelfInFile";
    AnnotationKind["Vararg"] = "vararg";
    AnnotationKind["ForRange"] = "forRange";
})(AnnotationKind = exports.AnnotationKind || (exports.AnnotationKind = {}));
function createAnnotation(name, args) {
    const kind = Object.values(AnnotationKind).find(k => k.toLowerCase() === name.toLowerCase());
    if (kind !== undefined) {
        return { kind, args };
    }
}
function collectAnnotations(source, annotationsMap) {
    var _a, _b;
    for (const tag of source.getJsDocTags()) {
        const annotation = createAnnotation(tag.name, (_b = (_a = tag.text) === null || _a === void 0 ? void 0 : _a.map(p => p.text)) !== null && _b !== void 0 ? _b : []);
        if (annotation) {
            annotationsMap.set(annotation.kind, annotation);
        }
    }
}
function getSymbolAnnotations(symbol) {
    const annotationsMap = new Map();
    collectAnnotations(symbol, annotationsMap);
    return annotationsMap;
}
exports.getSymbolAnnotations = getSymbolAnnotations;
function getTypeAnnotations(type) {
    const annotationsMap = new Map();
    if (type.symbol)
        collectAnnotations(type.symbol, annotationsMap);
    if (type.aliasSymbol)
        collectAnnotations(type.aliasSymbol, annotationsMap);
    return annotationsMap;
}
exports.getTypeAnnotations = getTypeAnnotations;
function getNodeAnnotations(node) {
    const annotationsMap = new Map();
    for (const tag of ts.getJSDocTags(node)) {
        const tagName = tag.tagName.text;
        const annotation = createAnnotation(tagName, getTagArgsFromComment(tag));
        if (annotation) {
            annotationsMap.set(annotation.kind, annotation);
        }
    }
    return annotationsMap;
}
exports.getNodeAnnotations = getNodeAnnotations;
function getFileAnnotations(sourceFile) {
    const annotationsMap = new Map();
    if (sourceFile.statements.length > 0) {
        // Manually collect jsDoc because `getJSDocTags` includes tags only from closest comment
        const jsDoc = sourceFile.statements[0].jsDoc;
        if (jsDoc) {
            for (const tag of jsDoc.flatMap(x => { var _a; return (_a = x.tags) !== null && _a !== void 0 ? _a : []; })) {
                const tagName = tag.tagName.text;
                const annotation = createAnnotation(tagName, getTagArgsFromComment(tag));
                if (annotation) {
                    annotationsMap.set(annotation.kind, annotation);
                }
            }
        }
    }
    return annotationsMap;
}
exports.getFileAnnotations = getFileAnnotations;
function getSignatureAnnotations(context, signature) {
    const annotationsMap = new Map();
    collectAnnotations(signature, annotationsMap);
    // Function properties on interfaces have the JSDoc tags on the parent PropertySignature
    const declaration = signature.getDeclaration();
    if ((declaration === null || declaration === void 0 ? void 0 : declaration.parent) && ts.isPropertySignature(declaration.parent)) {
        const symbol = context.checker.getSymbolAtLocation(declaration.parent.name);
        if (symbol) {
            collectAnnotations(symbol, annotationsMap);
        }
    }
    return annotationsMap;
}
exports.getSignatureAnnotations = getSignatureAnnotations;
function isTupleReturnCall(context, node) {
    if (!ts.isCallExpression(node)) {
        return false;
    }
    const signature = context.checker.getResolvedSignature(node);
    if (signature) {
        if (getSignatureAnnotations(context, signature).has(AnnotationKind.TupleReturn)) {
            return true;
        }
        // Only check function type for directive if it is declared as an interface or type alias
        const declaration = signature.getDeclaration();
        const isInterfaceOrAlias = (declaration === null || declaration === void 0 ? void 0 : declaration.parent) &&
            ((ts.isInterfaceDeclaration(declaration.parent) && ts.isCallSignatureDeclaration(declaration)) ||
                ts.isTypeAliasDeclaration(declaration.parent));
        if (!isInterfaceOrAlias) {
            return false;
        }
    }
    const type = context.checker.getTypeAtLocation(node.expression);
    return getTypeAnnotations(type).has(AnnotationKind.TupleReturn);
}
exports.isTupleReturnCall = isTupleReturnCall;
function isLuaIteratorType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.LuaIterator);
}
exports.isLuaIteratorType = isLuaIteratorType;
function isVarargType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.Vararg);
}
exports.isVarargType = isVarargType;
function isForRangeType(context, node) {
    const type = context.checker.getTypeAtLocation(node);
    return getTypeAnnotations(type).has(AnnotationKind.ForRange);
}
exports.isForRangeType = isForRangeType;
function getTagArgsFromComment(tag) {
    if (tag.comment) {
        if (typeof tag.comment === "string") {
            return tag.comment.split(" ");
        }
        else {
            return tag.comment.map(part => part.text);
        }
    }
    return [];
}
exports.getTagArgsFromComment = getTagArgsFromComment;
//# sourceMappingURL=annotations.js.map