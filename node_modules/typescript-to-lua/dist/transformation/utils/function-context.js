"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFunctionContextType = exports.getDeclarationContextType = exports.ContextType = void 0;
const ts = require("typescript");
const annotations_1 = require("./annotations");
const typescript_1 = require("./typescript");
var ContextType;
(function (ContextType) {
    ContextType[ContextType["None"] = 0] = "None";
    ContextType[ContextType["Void"] = 1] = "Void";
    ContextType[ContextType["NonVoid"] = 2] = "NonVoid";
    ContextType[ContextType["Mixed"] = 3] = "Mixed";
})(ContextType = exports.ContextType || (exports.ContextType = {}));
function hasNoSelfAncestor(declaration) {
    const scopeDeclaration = (0, typescript_1.findFirstNodeAbove)(declaration, (node) => ts.isSourceFile(node) || ts.isModuleDeclaration(node));
    if (!scopeDeclaration) {
        return false;
    }
    else if (ts.isSourceFile(scopeDeclaration)) {
        return (0, annotations_1.getFileAnnotations)(scopeDeclaration).has(annotations_1.AnnotationKind.NoSelfInFile);
    }
    else if ((0, annotations_1.getNodeAnnotations)(scopeDeclaration).has(annotations_1.AnnotationKind.NoSelf)) {
        return true;
    }
    else {
        return hasNoSelfAncestor(scopeDeclaration);
    }
}
function getExplicitThisParameter(signatureDeclaration) {
    return signatureDeclaration.parameters.find(param => ts.isIdentifier(param.name) && param.name.originalKeywordKind === ts.SyntaxKind.ThisKeyword);
}
function getDeclarationContextType({ program }, signatureDeclaration) {
    const thisParameter = getExplicitThisParameter(signatureDeclaration);
    if (thisParameter) {
        // Explicit 'this'
        return thisParameter.type && thisParameter.type.kind === ts.SyntaxKind.VoidKeyword
            ? ContextType.Void
            : ContextType.NonVoid;
    }
    // noSelf declaration on function signature
    if ((0, annotations_1.getNodeAnnotations)(signatureDeclaration).has(annotations_1.AnnotationKind.NoSelf)) {
        return ContextType.Void;
    }
    if (ts.isMethodSignature(signatureDeclaration) ||
        ts.isMethodDeclaration(signatureDeclaration) ||
        ts.isConstructSignatureDeclaration(signatureDeclaration) ||
        ts.isConstructorDeclaration(signatureDeclaration) ||
        (signatureDeclaration.parent && ts.isPropertyDeclaration(signatureDeclaration.parent)) ||
        (signatureDeclaration.parent && ts.isPropertySignature(signatureDeclaration.parent))) {
        // Class/interface methods only respect @noSelf on their parent
        const scopeDeclaration = (0, typescript_1.findFirstNodeAbove)(signatureDeclaration, (n) => ts.isClassDeclaration(n) || ts.isClassExpression(n) || ts.isInterfaceDeclaration(n));
        if (scopeDeclaration === undefined) {
            return ContextType.NonVoid;
        }
        if ((0, annotations_1.getNodeAnnotations)(scopeDeclaration).has(annotations_1.AnnotationKind.NoSelf)) {
            return ContextType.Void;
        }
        return ContextType.NonVoid;
    }
    // When using --noImplicitSelf and the signature is defined in a file targeted by the program apply the @noSelf rule.
    const options = program.getCompilerOptions();
    if (options.noImplicitSelf && program.getRootFileNames().includes(signatureDeclaration.getSourceFile().fileName)) {
        return ContextType.Void;
    }
    // Walk up to find @noSelf or @noSelfInFile
    if (hasNoSelfAncestor(signatureDeclaration)) {
        return ContextType.Void;
    }
    return ContextType.NonVoid;
}
exports.getDeclarationContextType = getDeclarationContextType;
function reduceContextTypes(contexts) {
    const reducer = (a, b) => {
        if (a === ContextType.None) {
            return b;
        }
        else if (b === ContextType.None) {
            return a;
        }
        else if (a !== b) {
            return ContextType.Mixed;
        }
        else {
            return a;
        }
    };
    return contexts.reduce(reducer, ContextType.None);
}
function getSignatureDeclarations(context, signatures) {
    return signatures.flatMap(signature => {
        const signatureDeclaration = signature.getDeclaration();
        let inferredType;
        if (ts.isMethodDeclaration(signatureDeclaration) &&
            ts.isObjectLiteralExpression(signatureDeclaration.parent) &&
            !getExplicitThisParameter(signatureDeclaration)) {
            inferredType = context.checker.getContextualTypeForObjectLiteralElement(signatureDeclaration);
        }
        else if ((ts.isFunctionExpression(signatureDeclaration) || ts.isArrowFunction(signatureDeclaration)) &&
            !getExplicitThisParameter(signatureDeclaration)) {
            // Infer type of function expressions/arrow functions
            inferredType = (0, typescript_1.inferAssignedType)(context, signatureDeclaration);
        }
        if (inferredType) {
            const inferredSignatures = (0, typescript_1.getAllCallSignatures)(inferredType);
            if (inferredSignatures.length > 0) {
                return inferredSignatures.map(s => s.getDeclaration());
            }
        }
        return signatureDeclaration;
    });
}
function getFunctionContextType(context, type) {
    var _a;
    if (type.isTypeParameter()) {
        type = (_a = type.getConstraint()) !== null && _a !== void 0 ? _a : type;
    }
    if (type.isUnion()) {
        return reduceContextTypes(type.types.map(t => getFunctionContextType(context, t)));
    }
    const signatures = context.checker.getSignaturesOfType(type, ts.SignatureKind.Call);
    if (signatures.length === 0) {
        return ContextType.None;
    }
    const signatureDeclarations = getSignatureDeclarations(context, signatures);
    return reduceContextTypes(signatureDeclarations.map(s => getDeclarationContextType(context, s)));
}
exports.getFunctionContextType = getFunctionContextType;
//# sourceMappingURL=function-context.js.map