"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAssignment = void 0;
const ts = require("typescript");
const utils_1 = require("../../utils");
const diagnostics_1 = require("./diagnostics");
const function_context_1 = require("./function-context");
// TODO: Clear if types are reused between compilations
const typeValidationCache = new WeakMap();
function validateAssignment(context, node, fromType, toType, toName) {
    if (toType === fromType) {
        return;
    }
    if ((toType.flags & ts.TypeFlags.Any) !== 0) {
        // Assigning to un-typed variable
        return;
    }
    // Use cache to avoid repeating check for same types (protects against infinite loop in recursive types)
    const fromTypeCache = (0, utils_1.getOrUpdate)(typeValidationCache, fromType, () => new Set());
    if (fromTypeCache.has(toType))
        return;
    fromTypeCache.add(toType);
    validateFunctionAssignment(context, node, fromType, toType, toName);
    const fromTypeNode = context.checker.typeToTypeNode(fromType, undefined, undefined);
    const toTypeNode = context.checker.typeToTypeNode(toType, undefined, undefined);
    if (!fromTypeNode || !toTypeNode) {
        return;
    }
    if ((ts.isArrayTypeNode(toTypeNode) || ts.isTupleTypeNode(toTypeNode)) &&
        (ts.isArrayTypeNode(fromTypeNode) || ts.isTupleTypeNode(fromTypeNode))) {
        // Recurse into arrays/tuples
        const fromTypeArguments = fromType.typeArguments;
        const toTypeArguments = toType.typeArguments;
        if (fromTypeArguments === undefined || toTypeArguments === undefined) {
            return;
        }
        const count = Math.min(fromTypeArguments.length, toTypeArguments.length);
        for (let i = 0; i < count; ++i) {
            validateAssignment(context, node, fromTypeArguments[i], toTypeArguments[i], toName);
        }
    }
    if ((toType.flags & ts.TypeFlags.Object) !== 0 &&
        (ts.isTypeLiteralNode(toTypeNode) ||
            (toType.objectFlags & ts.ObjectFlags.ClassOrInterface) !== 0) &&
        toType.symbol &&
        toType.symbol.members &&
        fromType.symbol &&
        fromType.symbol.members) {
        // Recurse into interfaces
        toType.symbol.members.forEach((toMember, escapedMemberName) => {
            if (fromType.symbol.members) {
                const fromMember = fromType.symbol.members.get(escapedMemberName);
                if (fromMember) {
                    const toMemberType = context.checker.getTypeOfSymbolAtLocation(toMember, node);
                    const fromMemberType = context.checker.getTypeOfSymbolAtLocation(fromMember, node);
                    const memberName = ts.unescapeLeadingUnderscores(escapedMemberName);
                    validateAssignment(context, node, fromMemberType, toMemberType, toName ? `${toName}.${memberName}` : memberName);
                }
            }
        });
    }
}
exports.validateAssignment = validateAssignment;
function validateFunctionAssignment(context, node, fromType, toType, toName) {
    const fromContext = (0, function_context_1.getFunctionContextType)(context, fromType);
    const toContext = (0, function_context_1.getFunctionContextType)(context, toType);
    if (fromContext === function_context_1.ContextType.Mixed || toContext === function_context_1.ContextType.Mixed) {
        context.diagnostics.push((0, diagnostics_1.unsupportedOverloadAssignment)(node, toName));
    }
    else if (fromContext !== toContext && fromContext !== function_context_1.ContextType.None && toContext !== function_context_1.ContextType.None) {
        context.diagnostics.push(toContext === function_context_1.ContextType.Void
            ? (0, diagnostics_1.unsupportedNoSelfFunctionConversion)(node, toName)
            : (0, diagnostics_1.unsupportedSelfFunctionConversion)(node, toName));
    }
}
//# sourceMappingURL=assignment-validation.js.map